{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#zodiax","title":"Zodiax","text":"<p>Zodiax is a lightweight extension to the object-oriented Jax framework Equinox. Equinox allows for differentiable classes that are recognised as a valid Jax type and Zodiax adds lightweight methods to simplify interfacing with these classes! Zodiax was originially built in the development of dLux and was designed to make working with large nested classes structures simple and flexible.</p> <p>Zodiax is directly integrated with both Jax and Equinox, gaining all of their core features:</p> <ul> <li> <p>Accelerated Numpy: a Numpy like API that can run on GPU and TPU</p> </li> <li> <p>Automatic Differentiation: Allows for optimisation and inference in extremely high dimensional spaces</p> </li> <li> <p>Just-In-Time Compilation: Compliles code into XLA at runtime and optimising execution across hardware</p> </li> <li> <p>Automatic Vectorisation: Allows for simple parallelism across hardware and asynchronys execution</p> </li> <li> <p>Object Oriented Jax: Allows for differentiable classes that are recognised as a valid Jax type</p> </li> <li> <p>Inbuilt Neural Networks: Has pre-built neural network layers classes</p> </li> <li> <p>Path-Based Pytree Interface: Path based indexing allows for easy interfacing with large and highly nested physical models</p> </li> <li> <p>Leaf Manipulation Methods: Inbuilt methods allow for easy manipulation of Pytrees mirroring the Jax Array API</p> </li> </ul> <p>Doccumentataion: louisdesdoigts.github.io/zodiax/</p> <p>Installation: <code>pip install zodiax</code></p> <p>Contributors: Louis Desdoigts</p> <p>Requires: Python 3.10+, Jax 0.4.3+</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Create a regular class that inherits from <code>zodiax.Base</code></p> <pre><code>import jax\nimport zodiax as zdx\nimport jax.numpy as np\n\nclass Linear(zdx.Base):\n    m : Jax.Array\n    b : Jax.Array\n\n    def __init__(self, m, b):\n        self.m = m\n        self.b = b\n\n    def model(self, x):\n        return self.m * x + self.b\n\nlinear = Linear(1., 1.)\n</code></pre> <p>Its that simple! The <code>linear</code> class is now a fully differentiable object that gives us all the benefits of jax with an object-oriented interface! Lets see how we can jit-compile and take gradients of this class.</p> <pre><code>@jax.jit\n@jax.grad\ndef loss_fn(model, xs, ys):\n    return np.square(model.model(xs) - ys).sum()\n\nxs = np.arange(5)\nys = 2*np.arange(5)\ngrads = loss_fn(linear, xs, ys)\nprint(grads)\nprint(grads.m, grads.b)\n</code></pre> <pre><code>&gt; Linear(m=f32[], b=f32[])\n&gt; -40.0 -10.0\n</code></pre> <p>The <code>grads</code> object is an instance of the <code>Linear</code> class with the gradients of the parameters with respect to the loss function!</p>"},{"location":"CHANGELOG/","title":"Example changelog","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit</p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2022, Louis Desdoigts All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"docs/faq/","title":"Frequently Asked Questions","text":"<p><code>FrozenInstanceError: cannot assign to field ' '</code></p> <p>This error is common when trying to assign a value to a field in Zodiax. This isn't possible becuase Jax and therefore Zodiax is immutable. Imutable objects can't be modified in place, instead a new instance of the object with the value updated is returned. This is mitigated simply by using the <code>.set</code>, <code>.add</code>, <code>.multiply</code> etc methods:</p> <pre><code>pytree = pytree.set('path', value)\npytree = pytree.add('path', value)\n</code></pre> <p><code>ValueError: The following fields were not initialised during __init__: {' '}</code></p> <p>This error is common when trying to initialise an class that has a bad <code>__init__</code> method. In order to be registered as an immutable PyTree all parameters must be set in the constructor!</p>"},{"location":"docs/usage/","title":"Using Zodiax","text":""},{"location":"docs/usage/#resources","title":"Resources","text":"<p>Zodiax is built from both Jax and Equinox, so if you are unfamiliar with those packages you should go through their docs and tutorials first! Here are some resources to get you started:</p> <ul> <li>Jax 101 tutorials</li> <li>Jax Pytrees</li> <li>All of Equinox</li> </ul>"},{"location":"docs/usage/#zodiax-basics","title":"Zodiax Basics","text":"<p><code>zodiax.Base</code> is the core class of Zodiax that registers instances of the class as a Pytree which is a native Jax object. Zodiax is also designed to ease working with complex nested class structures often nesseciateted by large physical models common to scientific programming. To do this <code>zodiax.Base</code> has a series of class methods that reflect the <code>jax</code> array update methods, along with introducing the concept of paths that can be used to access and update the leaves of a pytree.</p>"},{"location":"docs/usage/#constructing-a-zodiax-class","title":"Constructing a Zodiax class","text":"<p>Lets examine how these methods work by looking at an example class structure. We will start with a simple class that models a normal distribution and then build a class that contains multiple instances of this class:</p> <pre><code>import zodiax as zdx\nfrom jax import numpy as np, scipy as scp\n\nclass Normal(zdx.Base):\n\"\"\"Basic class for modelling a normal distribution\"\"\"\n    mean      : np.ndarray\n    scale     : np.ndarray\n    amplitude : np.ndarray\n\n\n    def __init__(self, mean, scale, amplitude):\n\"\"\"Constructor for the Normal class\"\"\"\n        self.mean      = np.asarray(mean,      dtype=float)\n        self.scale     = np.asarray(scale,     dtype=float)\n        self.amplitude = np.asarray(amplitude, dtype=float)\n\n\n    def model(self, width=10):\n\"\"\"Evaluates the normal distribution\"\"\"\n        xs = np.linspace(-width, width, 128)\n        return self.amplitude * scp.stats.norm.pdf(xs, self.mean, self.scale)\n</code></pre> <p>This class simply models a normal distribution with a mean, scale and amplitude, and has a <code>.model()</code> method that is used to actually perform the calculation of the normal distribution.</p> <p>Declaring attributes: <code>mean : np.ndarray</code></p> <p>When using <code>equinox</code> or <code>zodiax</code> the attibutes of the class must be declared in the class definition to determine the structure of the pytree that is created when the class is instantiated. This is done by adding a type hint to the attribute which can be any valid python type and is not type checked!</p> <p> <code>.model()</code> vs <code>.__call__()</code></p> <p>It is common in Equinox to not define a <code>.model()</code> method but rather a <code>.__call__()</code> method so that the instance of the class can be called like a function, ie:</p> <pre><code>normal = Normal(0, 1, 1)\ndistribution = normal(10)\n</code></pre> <p>This is a matter of personal preference, however when using Optax if you try to optimise a class that has a <code>.__call__()</code> method, you can thrown unhelpful errors. Becuase of this I recommend avoiding <code>.__call__()</code> methods and instead using <code>.model()</code> method.</p> <p>Now we construct a class to store and model a set of multiple normals.</p> <pre><code>class NormalSet(zdx.Base):\n\"\"\"Basic class for modelling a set of normal distributions\"\"\"\n    normals : dict\n    width   : np.ndarray\n\n\n    def __init__(self, means, scales, amplitude, names, width=10):\n\"\"\"Constructor for the NormalSet class\"\"\"\n        normals = {}\n        for i in range(len(names)):\n            normals[names[i]] = Normal(means[i], scales[i], amplitude[i])\n        self.normals = normals\n        self.width = np.asarray(width, dtype=float)\n\n\n    def __getattr__(self, key):\n\"\"\"Allows us to access the individual normals by their dictionary key\"\"\"\n        if key in self.normals.keys():\n            return self.normals[key]\n        else:\n            raise AttributeError(f\"{key} not in {self.normals.keys()}\")\n\n\n    def model(self):\n\"\"\"Evaluates the set of normal distributions\"\"\"\n        return np.array([normal.model(self.width) \n            for normal in self.normals.values()]).sum(0)\n\n\nsources = NormalSet([-1., 2.], [1., 2.], [2., 4.], ['alpha', 'beta'])\n</code></pre> <p>This <code>NormalSet</code> class now lets us store an arbitrary number of <code>Normal</code> objects in a dictionary, and allows us to access them by their dictionary key. We can also model the sum of all the normals using the <code>.model()</code> method.</p> <p>This is all the class set-up we need, now we can look at how to perform different types of optimisation and inference using this model.</p> <p>Whats with the <code>__getattr__</code> method?</p> <p>This method eases working with nested structures and canbe used to raise parameters from the lowst level of the class structure up to the top. In this example it allows us to access the individual <code>Normal</code> objects by their dictionary key. Using this method, these two lines are equivalent:</p> <pre><code>mu = sources.normals['alpha'].mean\nmu = sources.alpha.mean\n</code></pre> <p>These methods can be chained together with multiple nested classes to make accessing parameters across large models much simpler!</p> <p>It is strongly reccomended that your classes have a <code>__getattr__</code> method implemented as it makes working with nested structures much easier! When doing so it is important to ensure that the method raises the correct error when the attribute is not found. This is done by raising an <code>AttributeError</code> with a message that includes the name of the attribute that was not found. </p> <p>Lets print this object to have a look at what it looks like:</p> <pre><code>print(source)\n</code></pre> <pre><code>&gt; NormalSet(\n&gt;   normals={\n&gt;     'alpha':\n&gt;     Normal(mean=f32[], scale=f32[], amplitude=f32[]),\n&gt;     'beta':\n&gt;     Normal(mean=f32[], scale=f32[], amplitude=f32[])\n&gt;   },\n&gt;   width=f32[]\n&gt; )\n</code></pre> <p>Whats with the f32[2]?</p> <p>The <code>f32[2]</code> is the <code>jax</code> representation of a <code>numpy</code> array. The <code>f32</code> is the dtype and the <code>[2]</code> is the shape. The <code>jax</code> representation of a scalar is <code>f32[]</code>.</p>"},{"location":"docs/usage/#paths","title":"Paths","text":"<p>Paths are a simple concept that allows us to index a particular leaf of the pytree. The path is a string that is constructed by concatenating the names of the attributes that lead to the leaf. Regardless of the data type of the node, the path is always a string and joined by a period '.', here are some paths for the <code>source</code> class instance:</p> <pre><code>\"normals.alpha.mean\"\n\"normals.alpha.scale\"\n\"normals.beta.amplitude\"\n</code></pre> <p>Since we have constructed the <code>__getattr__</code> method, these paths can be simplified to:</p> <pre><code>\"alpha.mean\"\n\"alpha.scale\"\n\"beta.amplitude\"\n</code></pre> <p>Path Uniqueness</p> <p>Paths must be unique Paths should not have space in them to work properly with the <code>__getattrr__</code></p>"},{"location":"docs/usage/#class-methods","title":"Class Methods","text":"<p>Zodiax adds a series of methods that can be used to manipulate the nodes or leaves of these pytrees that mirror and expand the functionality of the <code>jax.Array.at[]</code> method. The main methods are <code>get</code>, <code>set</code>, <code>add</code>, <code>multiply</code>, <code>divide</code>, <code>power</code>, <code>min</code>, <code>max</code>, <code>apply</code> and <code>apply_args</code>. The first argument to these methods is a path and methods that manipulate leaves also take in a values parameter. They all essentially follow the same syntax so lets look at some examples of how we would perform basic operations to Zodiax obejcts.</p> <p>Lets change our 'alpha` source to a unit normal:</p> <pre><code>sources = sources.set('alpha.mean', 0.)\nsources = sources.set('alpha.scale', 1.)\nsources = sources.set('alpha.amplitude', 1.)\nprint(sources.alpha)\n</code></pre> <pre><code>&gt; Normal(mean=0.0, scale=1.0, amplitude=1.0)\n</code></pre> <p>Wait where did the <code>f32[]</code> go?</p> <p>This is because we have replaced the <code>jax</code> array with a python float!. It is important to note that the <code>set</code> method does not perform any type checking and will simply replace the leaf with whatever is passed in. Be careful when setting leaves to make sure they are the correct type and that you dont get unexpected errors down the line!</p> <p>Immutability</p> <p>Since Jax is immutable, Zodiax is also immutable. All this means is we can not update values in place and instead create a new instance of an object with the updated value.</p> <p>In regular (mutable) python if we wanted to update the value of some parameter in a class we would do something like this:</p> <pre><code>sources.alpha.mean = 4\nsources.alpha.mean += 2\n</code></pre> <p>However in Zodiax this will throw a <code>FrozenInstanceError</code>, what gives! Lets see how we can use Zodiax to achieve the same thing:</p> <pre><code>sources = sources.set('alpha.mean', 4)\nsources = sources.add('alpha.mean', 2)\n</code></pre>"},{"location":"docs/usage/#multiple-paths-and-nesting","title":"Multiple Paths and Nesting","text":"<p>Zodiax in very felixible in how you can use the paths to access and manipulate the leaves of the pytree. You can use a single path to access a single leaf, or you can use a list of paths to access multiple leaves. You can also use nested paths to access nested leaves. Lets see some examples:</p> <p>Lets add all of the paths to the means together so we can have a simple variable that we can use to globally shift all of the <code>sources</code> at the same time.</p> <pre><code>means = ['alpha.mean', 'beta.mean', 'gamma.mean']\nshifted_sources = sources.add(means, 2.5)\n</code></pre> <p>It's that easy! We can also nest paths in order to perform complex operations simply. Lets say we want to change the scale of both the 'alpha' and 'beta' source together and the 'gamma' source independently.</p> <pre><code>scales = [['alpha.scale', 'beta.scale'], 'gamma.scale']\nvalues = [2., 4.]\nscaled_sources = sources.multiply(scales, values)\n</code></pre> <p>This concept apllies to all of Zodiax and can be used with any of its methods. Similarly Zodiax is designed so that every update operations is performed simultaneously. This prevents the unessecary overhead of copy the entire contents of the pytree for every update which is especcially beneficial for large models!</p>"},{"location":"docs/usage/#optimisation-inference","title":"Optimisation &amp; Inference","text":"<p>Now that we have an understanding of how to construct and interact with Zodiax classes, lets see how we can use them to perform optimisation and inference on our model. We will start with a simple example of optimising a model using gradient descent, then show how to use the good deep mind gradient processing library Optax, then show how to use numpy to perform inference on the data, and finally show how to use derivates to calcaulte Fisher matrices. In these examples we will use the classes we created above.</p> <p>Create some fake data</p> <p>Now lets take a lott at how we can recover the parameters of the model using gradient descent. To do this we need to create some fake data which we will do by modelling the normals and adding some noise.</p> <p>Then we create a new instance of the model that we will use to recover the parameters from the data!</p> <pre><code>import jax.random as jr\nimport matplotlib.pyplot as plt\n\n# Make some data by adding some noise\nkey = jr.PRNGKey(0)\ntrue_signal = sources.model()\ndata = true_signal + jr.normal(key, sources.model().shape)/50\n\n# Create a model to initialise\ninitial_model = NormalSet([-3., 3.], [1., 1.], [2.5, 2.5], ['alpha', 'beta'])\n</code></pre> Plotting code <pre><code># Examine the data and the initial model\nplt.figure(figsize=(8, 4))\nxs = np.linspace(-sources.width, sources.width, len(data))\nplt.scatter(xs, data, s=10, label=\"Data\")\nplt.plot(xs, true_signal, alpha=0.75, label=\"True Signal\")\nplt.plot(xs, initial_model.model(), alpha=0.75, label=\"Initial model\")\nplt.axhline(0, color=\"k\", alpha=0.5)\nplt.title(\"Source Signal and data\")\nplt.xlabel(\"Position\")\nplt.ylabel(\"Intensity\")\nplt.legend()\nplt.show()\n</code></pre> <p></p> <p>Create a Loss Function</p> <p>Now lets create a loss function and use the gradients to perform a simple gradient descent recovery of the parameters:</p> <pre><code># Now lets construct a loss function\nopt_parameters = [\n    'alpha.mean', 'alpha.scale', 'alpha.amplitude',\n    'beta.mean', 'beta.scale', 'beta.amplitude'\n    ]\n@zdx.filter_jit\n@zdx.filter_value_and_grad(opt_parameters)\ndef loss_fn(model, data):\n    return np.square(model.model() - data).sum()\n\n# Evaluate loss function once Compile to XLA\nmodel = initial_model\nloss, grads = loss_fn(model, data)\n</code></pre> <p><code>@zdx.filter_jit</code>: Just-In-Time (jit) compilation</p> <p>The <code>@zdx.filter_jit</code> decorator is used to compile the function to XLA, which is done the first time it is called. This is not strictly necessary but it can speed up the function a huge amount and so it generally recommended. The reason we use this function and not the regular <code>@jax.jit</code> is that the Zodiax function will mark any non-optimisable parameters as static, such as strings. This allows us to create classes with extra meta-data that we don't have to manually declare as static!</p> <p><code>@zdx.filter_value_and_grad</code> &amp; <code>opt_parameters</code></p> <p>Why did we use the <code>@zdx.filter_value_and_grad</code> decorator and what is the <code>opt_pararmeters</code> variable? This filter function operates similarly to the <code>@zdx.filter_jit</code> decorator by preventaing gradients being taken with respect to strings and lets us specifiy exactly what parameters we want to optimise. In this case we want to optimise the parameters of the individual normals, so we pass a list of of paths to those parameters!</p>"},{"location":"docs/usage/#simple-gradeint-descent","title":"Simple Gradeint Descent","text":"<p>In gradient descent we update our parameters towards the minimum of the loss function by taking a step in the opposite direction of the gradient (towards the minimum). The size of this step is controlled by the learning rate, which is a hyper-parameter that we have to tune. In this case we have set the learning rate to <code>1e-2</code> and applied this learning rate to all of the parameters in the model using the inbuilt Zodiax <code>.multiply</code> function.</p> <pre><code>losses = []\nfor i in range(200):\n    loss, grads = loss_fn(model, data)\n    step = grads.multiply(opt_parameters, -1e-2)\n    model = zdx.apply_updates(model, step)\n    losses.append(loss)\n</code></pre> <p>How easy was that! Now lets examine the results:</p> Plotting code <pre><code>plt.figure(figsize=(12, 4))\nplt.subplot(1, 2, 1)\nplt.plot(np.log10(np.array(losses)))\nplt.title(\"Losses\")\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"Log10 Loss\")\n\nplt.subplot(1, 2, 2)\nplt.scatter(xs, data, s=10, label='Data')\nplt.plot(xs, model.model(), alpha=0.75, label='Recovered Model',  c='tab:green')\nplt.axhline(0, color=\"k\", alpha=0.5)\nplt.title(\"Data and Recovered Signal\")\nplt.xlabel(\"Position\")\nplt.ylabel(\"Intensity\")\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"docs/usage/#optax","title":"Optax","text":"<p>One of the other benfeits of using Zodiax is that our objects natively integrate in to the Jax optmisation ecosystem. For example we can use the Google DeepMind gradient processing libaray Optax in order to gain access to a series of gradient optimisation algorithms.</p> <p>We can re-use the loss function from above, so lets have a look how we can use some Optax optimisers:</p> <pre><code>import optax\n\n# Get optax objcets\nmodel = initial_model\noptimiser, state = zdx.get_optimiser(model, opt_parameters, optax.adam(1e-1))\n\nlosses = []\nfor i in range(200):\n    loss, grads = loss_fn(model, data)\n    step, state = optimiser.update(grads, state)\n    model = zdx.apply_updates(model, step)\n    losses.append(loss)\n</code></pre> <p><code>zdx.get_optimiser(model, parameters, optimisers)</code></p> <p>The <code>zdx.get_optimiser</code> function takes a model, a list of parameters to optimise and list of optimisers for each of the those parameters and returns an optax optimiser and an optax state object. This convenience function simply ensures that the we format our model correctly and map our optimisers correctly for Optax! These objects together are used to implement more complex gradient descent algorithms such as Adam, RMSProp, etc.</p> <p>Easy! Lets examine the results</p> Plotting code <pre><code>plt.figure(figsize=(12, 4))\nplt.subplot(1, 2, 1)\nplt.plot(np.log10(np.array(losses)))\nplt.title(\"Losses\")\nplt.xlabel(\"Epoch\")\nplt.ylabel(\"Log10 Loss\")\n\nplt.subplot(1, 2, 2)\nplt.scatter(xs, data, s=10, label='Data')\nplt.plot(xs, model.model(), alpha=0.75, label='Recovered Model',  c='tab:green')\nplt.axhline(0, color=\"k\", alpha=0.5)\nplt.title(\"Data and Recovered Signal\")\nplt.xlabel(\"Position\")\nplt.ylabel(\"Intensity\")\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"docs/usage/#fisher-inference","title":"Fisher Inference","text":"<p>The differentiable nature of Zodiax objects also allows us to perform inference on the parameters of our model. The Laplace approximation assumes that the posterior distribution of our model parameters is a gaussian distribution centred on the maximum likelihood estimate of the parameters. Luckily we can use autodiff to calculate the hessian of the log likelihood function and invert it to get the covariance matrix of the posterior distribution!</p> Fisher and Covariance Matrices <p>The covariance matrix \\(\\vec{\\Sigma}\\) describes the covariance between the parameters of a model. Under the Laplace approximation, we can calculate the covariance matrix using autodiff:</p> \\[ \\vec{\\Sigma}(\\vec{X}) = - \\Big[ \\nabla \\nabla \\text{ln} \\Big(       \\mathcal {L}(\\vec{X}) \\rho(\\vec{X}) \\Big) \\Big]^{-1} \\] <p>where \\(\\mathcal{L}\\) is the likelihood function and \\(\\rho\\) is the prior function. In this example we will assume a flat prior, so \\(\\rho(\\vec{X}) = 1\\).</p> <pre><code># Define the paramters we want to marginalise over\nparameters = ['alpha.mean',      'beta.mean', \n              'alpha.scale',     'beta.scale', \n              'alpha.amplitude', 'beta.amplitude']\n\n# Define Likelihod function\ndef chi2(X, model, data, noise=1):\n    signal = perturb(X, model).model()\n    return np.log10(np.square((signal - data) / noise).sum())\n\n# Define Perturbation function\ndef perturb(X, model):\n    for parameter, x in zip(parameters, X):\n        model = model.add(parameter, x)\n    return model\n\n# Define Covariance function\ndef calculate_covaraince(model, data):\n    X = np.zeros(len(parameters))\n    return -np.linalg.inv(jax.hessian(chi2)(X, model, data))\n\n# Calcuate parameter variances\ncovariance_matrix = calculate_covaraince(model, data)\ndeviations = np.abs(np.diag(covariance_matrix))**0.5\n</code></pre> <p>Lets examine the results:</p> Plotting code <pre><code>true_values = sources.get(parameters)\nrecoverd_parameters = model.get(parameters)\n\nformatted = [r\"$\\alpha_\\mu$\",    r\"$\\beta_\\mu$\",\n             r\"$\\alpha_\\sigma$\", r\"$\\beta_\\sigma$\",\n             r\"$\\alpha_A$\",      r\"$\\beta_A$\"]\n\nplt.figure(figsize=(8, 4))\nxs = np.arange(len(parameters))\nplt.bar(xs, true_values, tick_label=formatted, width=0.3, label='True')\nplt.bar(xs+0.33, recoverd_parameters, tick_label=formatted, yerr=deviations,\n    width=0.33, label='Recovered', capsize=3)\nplt.plot([], c='k', label='1-sigma')\nplt.axhline(0, color=\"k\", alpha=0.5)\nplt.legend(loc=2)\nplt.xlabel(\"Parameter\")\nplt.ylabel(\"Value\")\nplt.tight_layout()\nplt.savefig(\"fisher_fit\")\nplt.show()\n</code></pre> <p></p> <p>Fantastic, this method gives us a great way to estimate the uncertainty in our recovered model parameters!</p>"},{"location":"docs/usage/#numpyro","title":"Numpyro","text":"<p>Numpyro is a probabailistic programming library that allows us to perform efficient posterior sampling algorithms. Numpyro is also built in Jax and so is designed to that take advantage of differentiability in order to perform extremely high-dimensional inference!</p> <p>Lets see how Zodiax can be integrated with Numpyro to perform posterior sampling on our model parameters.</p> <pre><code>import numpyro as npy\nimport numpyro.distributions as dist\nimport chainconsumer as cc\n\ndef sampling_fn(data, model):\n    paths = [\"alpha.mean\",      \"beta.mean\", \n             \"alpha.scale\",     \"beta.scale\",\n             \"alpha.amplitude\", \"beta.amplitude\"]\n\n    # Define priors\n    values = [npy.sample(r\"\\alpha_\\mu\",    dist.Normal(0, 5)), \n              npy.sample(r\"\\beta_\\mu\",     dist.Normal(0, 5)),\n              npy.sample(r\"\\alpha_\\sigma\", dist.HalfNormal(5)), \n              npy.sample(r\"\\beta_\\sigma\",  dist.HalfNormal(5)),\n              npy.sample(r\"\\alpha_A\",      dist.Normal(0, 5)), \n              npy.sample(r\"\\beta_A\",       dist.Normal(0, 5))]\n\n    # Sample from the posterior distribution\n    with npy.plate(\"data\", len(data)):\n        model_sampler = dist.Normal(\n            model.set_and_call(paths, values, \"model\")\n            )\n        return npy.sample(\"Sampler\", model_sampler, obs=data)\n</code></pre> <p>Numpyo requires a 'sampling' function where you assign priors to your parameters and then sample from the posterior distribution. The syntax for this can be seen above. We then sample the data using a 'plate' and define a likelihood which in this case is a normal. The <code>set_and_call</code> function is a Zodiax function that allows us to update the model parameters and then return call some method of that class. This is the function that ultimately allows a simple interface with Numpyro.</p> <p>We then need to define our sampler which in this case is the No U-Turn Sampler (NUTS). NUTS is a variant of Hamiltonian Monte Carlo (HMC) that is designed to be more efficient and robust, and takes advantage of gradients to allow high dimensional inference.</p> <pre><code># Using the model above, we can now sample from the posterior distribution\n# using the No U-Turn Sampler (NUTS).\nsampler = npy.infer.MCMC(\n    npy.infer.NUTS(sampling_fn),\n    num_warmup=5000,\n    num_samples=5000,\n)\n%time sampler.run(jr.PRNGKey(0), data, model)\n</code></pre> <p>Fantastic now lets have a look at our posterior distributions!</p> Plotting code <pre><code>chain = cc.ChainConsumer()\nchain.add_chain(sampler.get_samples())\nchain.configure(\n    serif=True, shade=True, bar_shade=True, shade_alpha=0.2, spacing=1.0, max_ticks=3\n)\n\nfig = chain.plotter.plot()\nfig.set_size_inches((15, 15))\n</code></pre> <p></p>"},{"location":"docs/API/api/","title":"Modules Overview","text":"<p>Zodiax is a lightweight extension of Equinox and so only has a few modules and methods. Lets check them out!</p>"},{"location":"docs/API/api/#base","title":"Base","text":"<p>The <code>Base</code> class is the foundational object of Zodiax and is what allows for a path-based pytree interface. Classes that inherit from <code>Base</code> will gain methods that allow for operations and functions to be applied to leaves specified by their paths. Here is a summary of the methods:</p> <p>Getter Methods</p> <pre><code>value = pytree.get(paths)\n</code></pre> <p>Setter Methods</p> <pre><code>pytree = pytree.set(paths, values)\npytree = pytree.set_and_call(paths, values, call_fn)\n</code></pre> <p>Arithmetic Methods</p> <pre><code>pytree = pytree.add(paths, values)\npytree = pytree.multiply(paths, values)\npytree = pytree.divide(paths, values)\npytree = pytree.power(paths, values)\npytree = pytree.min(paths, values)\npytree = pytree.max(paths, values)\n</code></pre> <p>Functional Methods</p> <pre><code>pytree = pytree.apply(paths, fns)\npytree = pytree.apply_args(paths, fns, args)\npytree = pytree.apply_and_call(paths, fns, call_fn)\n</code></pre>"},{"location":"docs/API/api/#equinox","title":"Equinox","text":"<p>Zodiax designed to be a 'drop in' replacement for Equinox, this means that all Equinox functions are available through Zodiax! Functions in the main Equinox namespace are raised into the Zodiax namespace, meaning these two line will import the same function:</p> <pre><code>from equinox import filter_jit\nfrom zodiax import filter_jit\n</code></pre> <p>Some Equinox functions are overwritten in order to give a path based interface. Currently there are two functions that are overwritten, <code>filter_grad</code> and <code>filter_value_and_grad</code>. This means that the following two lines will import different functions:</p> <pre><code>from equinox import filter_grad\nfrom zodiax import filter_grad\n</code></pre> <p>Submodules in Equinox are also raised into the Zodiax namespace through the <code>zodiax.equinox</code> submodule. This is how you would import the <code>nn</code> submodule from either Equinox or Zodiax:</p> <pre><code>from equinox import nn\nfrom zodiax.equinox import nn\n</code></pre>"},{"location":"docs/API/api/#optimisation","title":"Optimisation","text":"<p>The <code>zodiax.optimisation</code> module contains only a single function, <code>get_optmiser</code>. It is a simple interface designed to apply Optax optimisers to individual leaves!</p>"},{"location":"docs/API/api/#tree","title":"Tree","text":"<p>The Tree module provides a module for helpful pytree manipulation functions. It only implements a single function, <code>get_args(paths)</code>. It returns a matching pytree with boolean leaves, where the leaves specified by <code>paths</code> are <code>True</code> and the rest are <code>False</code>.</p>"},{"location":"docs/API/api/#serialisation","title":"Serialisation","text":"<p>Serialisation is currently an experimental Module</p> <p>This module is currently experimental and may change in future versions.</p> <p>The Serialisation methods are designed to make it easy to save and load Zodiax models! There are two main functions: <code>serialise()</code> and <code>deserialise()</code>.</p>"},{"location":"docs/API/base/","title":"Base","text":"<p>The <code>Base</code> class is the foundational object of Zodiax and is what allows for a path-based pytree interface. Classes that inherit from <code>Base</code> will gain methods that allow for operations and functions to be applied to leaves specified by their paths. Here is a summary of the methods:</p> <p>Getter Methods</p> <pre><code>value = pytree.get(paths)\n</code></pre> <p>Setter Methods</p> <pre><code>pytree = pytree.set(paths, values)\npytree = pytree.set_and_call(paths, values, call_fn)\n</code></pre> <p>Arithmetic Methods</p> <pre><code>pytree = pytree.add(paths, values)\npytree = pytree.multiply(paths, values)\npytree = pytree.divide(paths, values)\npytree = pytree.power(paths, values)\npytree = pytree.min(paths, values)\npytree = pytree.max(paths, values)\n</code></pre> <p>Functional Methods</p> <pre><code>pytree = pytree.apply(paths, fns)\npytree = pytree.apply_args(paths, fns, args)\npytree = pytree.apply_and_call(paths, fns, call_fn)\n</code></pre> <p>Full API</p> <p>         Bases: <code>Module</code></p> <p>Extend the Equninox.Module class to give a user-friendly 'path based' API for working with pytrees by adding a series of methods used to interface with the leaves of the pytree using paths.</p> Source code in <code>zodiax/base.py</code> <pre><code>class Base(Module):\n\"\"\"\n    Extend the Equninox.Module class to give a user-friendly 'path based' API\n    for working with pytrees by adding a series of methods used to interface\n    with the leaves of the pytree using paths.\n    \"\"\"\n    def get(self : PyTree, paths : PathLike) -&gt; Any:\n\"\"\"\n        Get the leaf specified by path.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A list/tuple of nested paths to unwrap.\n\n        Returns\n        -------\n        leaf, leaves : Any, list\n            The leaf or list of leaves specified by paths.\n        \"\"\"\n        new_paths = _format(paths)\n        values = _get_leaves(self, new_paths)\n        return values[0] if len(new_paths) == 1 else values\n\n\n    def set(self   : PyTree,\n            paths  : PathLike,\n            values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n        Set the leaves specified by paths with values.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        values : Union[list[Any], Any]\n            The list of values to set at the leaves specified by paths.\n\n        Returns\n        -------\n        pytree : PyTree\n            The pytree with leaves specified by paths updated with values.\n        \"\"\"\n        new_paths, new_values = _format(paths, values)\n\n        # Define 'where' function and update pytree\n        leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n        return tree_at(leaves_fn, self, new_values,\n                      is_leaf = lambda leaf: leaf is None)\n\n\n    def add(self   : PyTree,\n            paths  : PathLike,\n            values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n        Add to the the leaves specified by paths with values.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        values : Union[list[Any], Any]\n            The list of values to add to the leaves specified by paths.\n\n        Returns\n        -------\n        pytree : PyTree\n            The pytree with values added to leaves specified by paths.\n        \"\"\"\n        new_paths, new_values = _format(paths, values)\n        new_values = [leaf + value for value, leaf in zip(new_values, \\\n                                    _get_leaves(self, new_paths))]\n\n        # Define 'where' function and update pytree\n        leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n        return tree_at(leaves_fn, self, new_values,\n                      is_leaf = lambda leaf: leaf is None)\n\n\n    def multiply(self   : PyTree,\n                 paths  : PathLike,\n                 values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n        Multiplies the the leaves specified by paths with values.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        values : Union[list[Any], Any]\n            The list of values to multiply the leaves specified by paths.\n\n        Returns\n        -------\n        pytree : PyTree\n            The pytree with values multiplied by leaves specified by paths.\n        \"\"\"\n        new_paths, new_values = _format(paths, values)\n        new_values = [leaf * value for value, leaf in zip(new_values, \\\n                                    _get_leaves(self, new_paths))]\n\n        # Define 'where' function and update pytree\n        leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n        return tree_at(leaves_fn, self, new_values,\n                      is_leaf = lambda leaf: leaf is None)\n\n\n    def divide(self   : PyTree,\n               paths  : PathLike,\n               values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n        Divides the the leaves specified by paths with values.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        values : Union[list[Any], Any]\n            The list of values to divide the leaves specified by paths.\n\n        Returns\n        -------\n        pytree : PyTree\n            The pytree with values divided by leaves specified by paths.\n        \"\"\"\n        new_paths, new_values = _format(paths, values)\n        new_values = [leaf / value for value, leaf in zip(new_values, \\\n                                    _get_leaves(self, new_paths))]\n\n        # Define 'where' function and update pytree\n        leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n        return tree_at(leaves_fn, self, new_values,\n                      is_leaf = lambda leaf: leaf is None)\n\n\n    def power(self   : PyTree,\n              paths  : PathLike,\n              values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n        Raises th leaves specified by paths to the power of values.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        values : Union[list[Any], Any]\n            The list of values to take the leaves specified by paths to the\n            power of.\n\n        Returns\n        -------\n        pytree : PyTree\n            The pytree with the leaves specified by paths raised to the power\n            of values.\n        \"\"\"\n        new_paths, new_values = _format(paths, values)\n        new_values = [leaf ** value for value, leaf in zip(new_values, \\\n                                    _get_leaves(self, new_paths))]\n\n        # Define 'where' function and update pytree\n        leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n        return tree_at(leaves_fn, self, new_values,\n                      is_leaf = lambda leaf: leaf is None)\n\n\n    def min(self   : PyTree,\n            paths  : PathLike,\n            values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n        Updates the leaves specified by paths with the minimum value of the\n        leaves and values.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        values : Union[list[Any], Any]\n            The list of values to take the minimum of and the leaf.\n\n        Returns\n        -------\n        pytree : PyTree\n            The pytree with the leaves specified by paths updated with the\n            minimum value of the leaf and values.\n        \"\"\"\n        new_paths, new_values = _format(paths, values)\n        new_values = [np.minimum(leaf, value) for value, leaf in \\\n                    zip(new_values, _get_leaves(self, new_paths))]\n\n        # Define 'where' function and update pytree\n        leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n        return tree_at(leaves_fn, self, new_values,\n                      is_leaf = lambda leaf: leaf is None)\n\n\n    def max(self   : PyTree,\n            paths  : PathLike,\n            values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n        Updates the leaves specified by paths with the maximum value of the\n        leaves and values.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        values : Union[list[Any], Any]\n            The list of values to take the maximum of and the leaf.\n\n        Returns\n        -------\n        pytree : PyTree\n            The pytree with the leaves specified by paths updated with the\n            maximum value of the leaf and values.\n        \"\"\"\n        new_paths, new_values = _format(paths, values)\n        new_values = [np.maximum(leaf, value) for value, leaf in \\\n                    zip(new_values, _get_leaves(self, new_paths))]\n\n        # Define 'where' function and update pytree\n        leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n        return tree_at(leaves_fn, self, new_values,\n                      is_leaf = lambda leaf: leaf is None)\n\n\n    def apply(self  : PyTree,\n              paths : PathLike,\n              fns   : Union[list[Callable], Callable]) -&gt; PyTree:\n\"\"\"\n        Applies the functions within fns the leaves specified by paths.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        fns : Union[list[Callable], Callable]\n            The list of functions to apply to the leaves.\n\n        Returns\n        -------\n        pytree : PyTree\n            The pytree with fns applied to the leaves specified by paths.\n        \"\"\"\n        new_paths, new_fns = _format(paths, fns)\n        new_values = [fn(leaf) for fn, leaf in zip(new_fns, \\\n                                    _get_leaves(self, new_paths))]\n\n        # Define 'where' function and update pytree\n        leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n        return tree_at(leaves_fn, self, new_values,\n                      is_leaf = lambda leaf: leaf is None)\n\n\n    def apply_args(self  : PyTree,\n                   paths : PathLike,\n                   fns   : Union[list[Callable], Callable],\n                   args  : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n        Applies the functions within fns the leaves specified by paths, while\n        also passing in args to the function.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        fns : Union[list[Callable], Callable]\n            The list of functions to apply to the leaves.\n        args : Union[list[Any], Any]\n            The tupe or list of tuples of extra arguments to pass into fns.\n\n        Returns\n        -------\n        pytree : PyTree\n            The pytree with fns applied to the leaves specified by paths with\n            the extra args passed in.\n        \"\"\"\n        new_paths, new_fns = _format(paths, fns)\n        new_paths, new_args = _format(paths, args)\n        new_values = [fn(leaf, *args) for fn, args, leaf in zip(new_fns, \\\n                            new_args, _get_leaves(self, new_paths))]\n\n        # Define 'where' function and update pytree\n        leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n        return tree_at(leaves_fn, self, new_values,\n                      is_leaf = lambda leaf: leaf is None)\n\n\n    def set_and_call(self    : PyTree,\n                     paths   : PathLike,\n                     values  : Union[list[Any], Any],\n                     call_fn : str,\n                     **kwargs) -&gt; Any:\n\"\"\"\n        Updates the leaves speficied by paths with values, and then calls the\n        function specified by the string call_fn, returning whatever is\n        returnd by the call_fn. Any extra positional arguments or key-word\n        arguments are passed through to the modelling function.\n\n        This function is desigend to be used in conjunction with numpyro.\n        Please go through the 'PyTree interface' tutorial to see how this\n        is used.\n\n        Parameters\n        ----------\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        values : Union[list[Any], Any]\n            The list of values to set at the leaves specified by paths.\n        call_fn : str\n            A string specifying which model function to call.\n\n        Returns\n        -------\n            : Any\n            Whatever object is returned by call_fn.\n        \"\"\"\n        return getattr(self.set(paths, values), call_fn)(**kwargs)\n\n\n    def apply_and_call(self     : PyTree,\n                       paths    : PathLike,\n                       fns      : Union[list[Callable], Callable],\n                       call_fn  : str,\n                       **kwargs) -&gt; object:\n\"\"\"\n        Applies the functions specified by fns to the leaves speficied by\n        paths, and then calls the function specified by the string call_fn,\n        returning whatever is returnd by the call_fn. Any extra positional\n        arguments or keyword arguments are passed through to the modelling\n        function.\n\n        Parameters\n        ----------\n        call_fn : str\n            A string specifying which model function to call.\n        paths : PathLike\n            A path or list of paths or list of nested paths.\n        fns : Union[list[Callable], Callable]\n            The list of functions to apply to the leaves.\n\n        Returns\n        -------\n            : Any\n            Whatever object is returned by call_fn.\n        \"\"\"\n        return getattr(self.apply(paths, fns), call_fn)(**kwargs)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.add","title":"<code>add(paths, values)</code>","text":"<p>Add to the the leaves specified by paths with values.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>values</code> <code>Union[list[Any], Any]</code> <p>The list of values to add to the leaves specified by paths.</p> required <p>Returns:</p> Name Type Description <code>pytree</code> <code>PyTree</code> <p>The pytree with values added to leaves specified by paths.</p> Source code in <code>zodiax/base.py</code> <pre><code>def add(self   : PyTree,\n        paths  : PathLike,\n        values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n    Add to the the leaves specified by paths with values.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    values : Union[list[Any], Any]\n        The list of values to add to the leaves specified by paths.\n\n    Returns\n    -------\n    pytree : PyTree\n        The pytree with values added to leaves specified by paths.\n    \"\"\"\n    new_paths, new_values = _format(paths, values)\n    new_values = [leaf + value for value, leaf in zip(new_values, \\\n                                _get_leaves(self, new_paths))]\n\n    # Define 'where' function and update pytree\n    leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n    return tree_at(leaves_fn, self, new_values,\n                  is_leaf = lambda leaf: leaf is None)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.apply","title":"<code>apply(paths, fns)</code>","text":"<p>Applies the functions within fns the leaves specified by paths.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>fns</code> <code>Union[list[Callable], Callable]</code> <p>The list of functions to apply to the leaves.</p> required <p>Returns:</p> Name Type Description <code>pytree</code> <code>PyTree</code> <p>The pytree with fns applied to the leaves specified by paths.</p> Source code in <code>zodiax/base.py</code> <pre><code>def apply(self  : PyTree,\n          paths : PathLike,\n          fns   : Union[list[Callable], Callable]) -&gt; PyTree:\n\"\"\"\n    Applies the functions within fns the leaves specified by paths.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    fns : Union[list[Callable], Callable]\n        The list of functions to apply to the leaves.\n\n    Returns\n    -------\n    pytree : PyTree\n        The pytree with fns applied to the leaves specified by paths.\n    \"\"\"\n    new_paths, new_fns = _format(paths, fns)\n    new_values = [fn(leaf) for fn, leaf in zip(new_fns, \\\n                                _get_leaves(self, new_paths))]\n\n    # Define 'where' function and update pytree\n    leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n    return tree_at(leaves_fn, self, new_values,\n                  is_leaf = lambda leaf: leaf is None)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.apply_and_call","title":"<code>apply_and_call(paths, fns, call_fn, **kwargs)</code>","text":"<p>Applies the functions specified by fns to the leaves speficied by paths, and then calls the function specified by the string call_fn, returning whatever is returnd by the call_fn. Any extra positional arguments or keyword arguments are passed through to the modelling function.</p> <p>Parameters:</p> Name Type Description Default <code>call_fn</code> <code>str</code> <p>A string specifying which model function to call.</p> required <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>fns</code> <code>Union[list[Callable], Callable]</code> <p>The list of functions to apply to the leaves.</p> required <p>Returns:</p> Type Description <code> </code> <p>Whatever object is returned by call_fn.</p> Source code in <code>zodiax/base.py</code> <pre><code>def apply_and_call(self     : PyTree,\n                   paths    : PathLike,\n                   fns      : Union[list[Callable], Callable],\n                   call_fn  : str,\n                   **kwargs) -&gt; object:\n\"\"\"\n    Applies the functions specified by fns to the leaves speficied by\n    paths, and then calls the function specified by the string call_fn,\n    returning whatever is returnd by the call_fn. Any extra positional\n    arguments or keyword arguments are passed through to the modelling\n    function.\n\n    Parameters\n    ----------\n    call_fn : str\n        A string specifying which model function to call.\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    fns : Union[list[Callable], Callable]\n        The list of functions to apply to the leaves.\n\n    Returns\n    -------\n        : Any\n        Whatever object is returned by call_fn.\n    \"\"\"\n    return getattr(self.apply(paths, fns), call_fn)(**kwargs)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.apply_args","title":"<code>apply_args(paths, fns, args)</code>","text":"<p>Applies the functions within fns the leaves specified by paths, while also passing in args to the function.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>fns</code> <code>Union[list[Callable], Callable]</code> <p>The list of functions to apply to the leaves.</p> required <code>args</code> <code>Union[list[Any], Any]</code> <p>The tupe or list of tuples of extra arguments to pass into fns.</p> required <p>Returns:</p> Name Type Description <code>pytree</code> <code>PyTree</code> <p>The pytree with fns applied to the leaves specified by paths with the extra args passed in.</p> Source code in <code>zodiax/base.py</code> <pre><code>def apply_args(self  : PyTree,\n               paths : PathLike,\n               fns   : Union[list[Callable], Callable],\n               args  : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n    Applies the functions within fns the leaves specified by paths, while\n    also passing in args to the function.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    fns : Union[list[Callable], Callable]\n        The list of functions to apply to the leaves.\n    args : Union[list[Any], Any]\n        The tupe or list of tuples of extra arguments to pass into fns.\n\n    Returns\n    -------\n    pytree : PyTree\n        The pytree with fns applied to the leaves specified by paths with\n        the extra args passed in.\n    \"\"\"\n    new_paths, new_fns = _format(paths, fns)\n    new_paths, new_args = _format(paths, args)\n    new_values = [fn(leaf, *args) for fn, args, leaf in zip(new_fns, \\\n                        new_args, _get_leaves(self, new_paths))]\n\n    # Define 'where' function and update pytree\n    leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n    return tree_at(leaves_fn, self, new_values,\n                  is_leaf = lambda leaf: leaf is None)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.divide","title":"<code>divide(paths, values)</code>","text":"<p>Divides the the leaves specified by paths with values.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>values</code> <code>Union[list[Any], Any]</code> <p>The list of values to divide the leaves specified by paths.</p> required <p>Returns:</p> Name Type Description <code>pytree</code> <code>PyTree</code> <p>The pytree with values divided by leaves specified by paths.</p> Source code in <code>zodiax/base.py</code> <pre><code>def divide(self   : PyTree,\n           paths  : PathLike,\n           values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n    Divides the the leaves specified by paths with values.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    values : Union[list[Any], Any]\n        The list of values to divide the leaves specified by paths.\n\n    Returns\n    -------\n    pytree : PyTree\n        The pytree with values divided by leaves specified by paths.\n    \"\"\"\n    new_paths, new_values = _format(paths, values)\n    new_values = [leaf / value for value, leaf in zip(new_values, \\\n                                _get_leaves(self, new_paths))]\n\n    # Define 'where' function and update pytree\n    leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n    return tree_at(leaves_fn, self, new_values,\n                  is_leaf = lambda leaf: leaf is None)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.get","title":"<code>get(paths)</code>","text":"<p>Get the leaf specified by path.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A list/tuple of nested paths to unwrap.</p> required <p>Returns:</p> Type Description <code>leaf, leaves</code> <p>The leaf or list of leaves specified by paths.</p> Source code in <code>zodiax/base.py</code> <pre><code>def get(self : PyTree, paths : PathLike) -&gt; Any:\n\"\"\"\n    Get the leaf specified by path.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A list/tuple of nested paths to unwrap.\n\n    Returns\n    -------\n    leaf, leaves : Any, list\n        The leaf or list of leaves specified by paths.\n    \"\"\"\n    new_paths = _format(paths)\n    values = _get_leaves(self, new_paths)\n    return values[0] if len(new_paths) == 1 else values\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.max","title":"<code>max(paths, values)</code>","text":"<p>Updates the leaves specified by paths with the maximum value of the leaves and values.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>values</code> <code>Union[list[Any], Any]</code> <p>The list of values to take the maximum of and the leaf.</p> required <p>Returns:</p> Name Type Description <code>pytree</code> <code>PyTree</code> <p>The pytree with the leaves specified by paths updated with the maximum value of the leaf and values.</p> Source code in <code>zodiax/base.py</code> <pre><code>def max(self   : PyTree,\n        paths  : PathLike,\n        values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n    Updates the leaves specified by paths with the maximum value of the\n    leaves and values.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    values : Union[list[Any], Any]\n        The list of values to take the maximum of and the leaf.\n\n    Returns\n    -------\n    pytree : PyTree\n        The pytree with the leaves specified by paths updated with the\n        maximum value of the leaf and values.\n    \"\"\"\n    new_paths, new_values = _format(paths, values)\n    new_values = [np.maximum(leaf, value) for value, leaf in \\\n                zip(new_values, _get_leaves(self, new_paths))]\n\n    # Define 'where' function and update pytree\n    leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n    return tree_at(leaves_fn, self, new_values,\n                  is_leaf = lambda leaf: leaf is None)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.min","title":"<code>min(paths, values)</code>","text":"<p>Updates the leaves specified by paths with the minimum value of the leaves and values.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>values</code> <code>Union[list[Any], Any]</code> <p>The list of values to take the minimum of and the leaf.</p> required <p>Returns:</p> Name Type Description <code>pytree</code> <code>PyTree</code> <p>The pytree with the leaves specified by paths updated with the minimum value of the leaf and values.</p> Source code in <code>zodiax/base.py</code> <pre><code>def min(self   : PyTree,\n        paths  : PathLike,\n        values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n    Updates the leaves specified by paths with the minimum value of the\n    leaves and values.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    values : Union[list[Any], Any]\n        The list of values to take the minimum of and the leaf.\n\n    Returns\n    -------\n    pytree : PyTree\n        The pytree with the leaves specified by paths updated with the\n        minimum value of the leaf and values.\n    \"\"\"\n    new_paths, new_values = _format(paths, values)\n    new_values = [np.minimum(leaf, value) for value, leaf in \\\n                zip(new_values, _get_leaves(self, new_paths))]\n\n    # Define 'where' function and update pytree\n    leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n    return tree_at(leaves_fn, self, new_values,\n                  is_leaf = lambda leaf: leaf is None)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.multiply","title":"<code>multiply(paths, values)</code>","text":"<p>Multiplies the the leaves specified by paths with values.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>values</code> <code>Union[list[Any], Any]</code> <p>The list of values to multiply the leaves specified by paths.</p> required <p>Returns:</p> Name Type Description <code>pytree</code> <code>PyTree</code> <p>The pytree with values multiplied by leaves specified by paths.</p> Source code in <code>zodiax/base.py</code> <pre><code>def multiply(self   : PyTree,\n             paths  : PathLike,\n             values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n    Multiplies the the leaves specified by paths with values.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    values : Union[list[Any], Any]\n        The list of values to multiply the leaves specified by paths.\n\n    Returns\n    -------\n    pytree : PyTree\n        The pytree with values multiplied by leaves specified by paths.\n    \"\"\"\n    new_paths, new_values = _format(paths, values)\n    new_values = [leaf * value for value, leaf in zip(new_values, \\\n                                _get_leaves(self, new_paths))]\n\n    # Define 'where' function and update pytree\n    leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n    return tree_at(leaves_fn, self, new_values,\n                  is_leaf = lambda leaf: leaf is None)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.power","title":"<code>power(paths, values)</code>","text":"<p>Raises th leaves specified by paths to the power of values.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>values</code> <code>Union[list[Any], Any]</code> <p>The list of values to take the leaves specified by paths to the power of.</p> required <p>Returns:</p> Name Type Description <code>pytree</code> <code>PyTree</code> <p>The pytree with the leaves specified by paths raised to the power of values.</p> Source code in <code>zodiax/base.py</code> <pre><code>def power(self   : PyTree,\n          paths  : PathLike,\n          values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n    Raises th leaves specified by paths to the power of values.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    values : Union[list[Any], Any]\n        The list of values to take the leaves specified by paths to the\n        power of.\n\n    Returns\n    -------\n    pytree : PyTree\n        The pytree with the leaves specified by paths raised to the power\n        of values.\n    \"\"\"\n    new_paths, new_values = _format(paths, values)\n    new_values = [leaf ** value for value, leaf in zip(new_values, \\\n                                _get_leaves(self, new_paths))]\n\n    # Define 'where' function and update pytree\n    leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n    return tree_at(leaves_fn, self, new_values,\n                  is_leaf = lambda leaf: leaf is None)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.set","title":"<code>set(paths, values)</code>","text":"<p>Set the leaves specified by paths with values.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>values</code> <code>Union[list[Any], Any]</code> <p>The list of values to set at the leaves specified by paths.</p> required <p>Returns:</p> Name Type Description <code>pytree</code> <code>PyTree</code> <p>The pytree with leaves specified by paths updated with values.</p> Source code in <code>zodiax/base.py</code> <pre><code>def set(self   : PyTree,\n        paths  : PathLike,\n        values : Union[list[Any], Any]) -&gt; PyTree:\n\"\"\"\n    Set the leaves specified by paths with values.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    values : Union[list[Any], Any]\n        The list of values to set at the leaves specified by paths.\n\n    Returns\n    -------\n    pytree : PyTree\n        The pytree with leaves specified by paths updated with values.\n    \"\"\"\n    new_paths, new_values = _format(paths, values)\n\n    # Define 'where' function and update pytree\n    leaves_fn = lambda pytree: _get_leaves(pytree, new_paths)\n    return tree_at(leaves_fn, self, new_values,\n                  is_leaf = lambda leaf: leaf is None)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base.set_and_call","title":"<code>set_and_call(paths, values, call_fn, **kwargs)</code>","text":"<p>Updates the leaves speficied by paths with values, and then calls the function specified by the string call_fn, returning whatever is returnd by the call_fn. Any extra positional arguments or key-word arguments are passed through to the modelling function.</p> <p>This function is desigend to be used in conjunction with numpyro. Please go through the 'PyTree interface' tutorial to see how this is used.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>PathLike</code> <p>A path or list of paths or list of nested paths.</p> required <code>values</code> <code>Union[list[Any], Any]</code> <p>The list of values to set at the leaves specified by paths.</p> required <code>call_fn</code> <code>str</code> <p>A string specifying which model function to call.</p> required <p>Returns:</p> Type Description <code> </code> <p>Whatever object is returned by call_fn.</p> Source code in <code>zodiax/base.py</code> <pre><code>def set_and_call(self    : PyTree,\n                 paths   : PathLike,\n                 values  : Union[list[Any], Any],\n                 call_fn : str,\n                 **kwargs) -&gt; Any:\n\"\"\"\n    Updates the leaves speficied by paths with values, and then calls the\n    function specified by the string call_fn, returning whatever is\n    returnd by the call_fn. Any extra positional arguments or key-word\n    arguments are passed through to the modelling function.\n\n    This function is desigend to be used in conjunction with numpyro.\n    Please go through the 'PyTree interface' tutorial to see how this\n    is used.\n\n    Parameters\n    ----------\n    paths : PathLike\n        A path or list of paths or list of nested paths.\n    values : Union[list[Any], Any]\n        The list of values to set at the leaves specified by paths.\n    call_fn : str\n        A string specifying which model function to call.\n\n    Returns\n    -------\n        : Any\n        Whatever object is returned by call_fn.\n    \"\"\"\n    return getattr(self.set(paths, values), call_fn)(**kwargs)\n</code></pre>"},{"location":"docs/API/base/#zodiax.base.Base","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.add","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.apply","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.apply_and_call","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.apply_args","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.divide","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.get","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.max","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.min","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.multiply","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.power","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.set","title":"Base","text":""},{"location":"docs/API/base/#zodiax.base.Base.set_and_call","title":"Base","text":""},{"location":"docs/API/equinox/","title":"Equinox","text":"<p>Zodiax designed to be a 'drop in' replacement for Equinox, this means that all Equinox functions are available through Zodiax! Functions in the main Equinox namespace are raised into the Zodiax namespace, meaning these two line will import the same function:</p> <pre><code>from equinox import filter_jit\nfrom zodiax import filter_jit\n</code></pre> <p>Some Equinox functions are overwritten in order to give a path based interface. Currently there are two functions that are overwritten, <code>filter_grad</code> and <code>filter_value_and_grad</code>. This means that the following two lines will import different functions:</p> <pre><code>from equinox import filter_grad\nfrom zodiax import filter_grad\n</code></pre> <p>Submodules in Equinox are also raised into the Zodiax namespace through the <code>zodiax.equinox</code> submodule. This is how you would import the <code>nn</code> submodule from either Equinox or Zodiax:</p> <pre><code>from equinox import nn\nfrom zodiax.equinox import nn\n</code></pre> <p>Full API</p>"},{"location":"docs/API/equinox/#zodiax.equinox.filter_grad","title":"<code>filter_grad(params, *filter_args, **filter_kwargs)</code>","text":"<p>Applies the equinox filter_grad function to the input params. The  corresponding equinox docs are found here</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Union[PyTree, list, str]</code> <p>The params to filter. Can either be a single string path, a list of  paths, or a pytree with binary leaves denoting which argument to take gradients with respect to.</p> required <code>*filter_args</code> <code>Any</code> <p>The args to pass to the equinox filter_grad function.</p> <code>()</code> <code>**filter_kwargs</code> <code>Any</code> <p>The kwargs to pass to the equinox filter_grad function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The wrapped function.</p> Source code in <code>zodiax/equinox.py</code> <pre><code>def filter_grad(params : Union[PyTree, list, str], \n                *filter_args, **filter_kwargs) -&gt; Callable:\n\"\"\"\n    Applies the equinox filter_grad function to the input params. The \n    corresponding equinox docs are found [here](https://docs.kidger.site/\n    equinox/api/filtering/transformations/)\n\n\n    Parameters\n    ----------\n    params : Union[PyTree, list, str]\n        The params to filter. Can either be a single string path, a list of \n        paths, or a pytree with binary leaves denoting which argument to take\n        gradients with respect to.\n    *filter_args : Any\n        The args to pass to the equinox filter_grad function.\n    **filter_kwargs : Any\n        The kwargs to pass to the equinox filter_grad function.\n\n    Returns\n    -------\n    Callable\n        The wrapped function.\n    \"\"\"\n    def wrapper(func : Callable):\n\n        @wraps(func)\n        def inner_wrapper(pytree : PyTree, *args, **kwargs):\n\n            # Convert params to filter spec if not already\n            filter_spec = _convert_to_filter(pytree, params)\n\n            # Wrap original function\n            @equinox.filter_grad(*filter_args, **filter_kwargs)\n            def recombine(diff : PyTree, non_diff : PyTree):\n                return func(combine(diff, non_diff), *args, **kwargs)\n\n            # Return wrapped function\n            return recombine(*partition(pytree, filter_spec))\n        return inner_wrapper\n    return wrapper\n</code></pre>"},{"location":"docs/API/equinox/#zodiax.equinox.filter_value_and_grad","title":"<code>filter_value_and_grad(params, *filter_args, **filter_kwargs)</code>","text":"<p>Applies the equinox filter_value_and_grad function to the input params. The  corresponding equinox docs are found here</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Union[PyTree, list, str]</code> <p>The params to filter. Can either be a single string path, a list of  paths, or a pytree with binary leaves denoting which argument to take gradients with respect to.</p> required <code>*filter_args</code> <code>Any</code> <p>The args to pass to the equinox filter_value_and_grad function.</p> <code>()</code> <code>**filter_kwargs</code> <code>Any</code> <p>The kwargs to pass to the equinox filter_value_and_grad function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The wrapped function.</p> Source code in <code>zodiax/equinox.py</code> <pre><code>def filter_value_and_grad(params : Union[PyTree, list, str], \n                *filter_args, **filter_kwargs) -&gt; Callable:\n\"\"\"\n    Applies the equinox filter_value_and_grad function to the input params. The \n    corresponding equinox docs are found [here](https://docs.kidger.site/\n    equinox/api/filtering/transformations/)\n\n    Parameters\n    ----------\n    params : Union[PyTree, list, str]\n        The params to filter. Can either be a single string path, a list of \n        paths, or a pytree with binary leaves denoting which argument to take\n        gradients with respect to.\n    *filter_args : Any\n        The args to pass to the equinox filter_value_and_grad function.\n    **filter_kwargs : Any\n        The kwargs to pass to the equinox filter_value_and_grad function.\n\n    Returns\n    -------\n    Callable\n        The wrapped function.\n    \"\"\"\n    def wrapper(func : Callable):\n\n        @wraps(func)\n        def inner_wrapper(pytree : PyTree, *args, **kwargs):\n\n            # Convert params to filter spec if not already\n            filter_spec = _convert_to_filter(pytree, params)\n\n            # Wrap original function\n            @equinox.filter_value_and_grad(*filter_args, **filter_kwargs)\n            def recombine(diff : PyTree, non_diff : PyTree):\n                return func(combine(diff, non_diff), *args, **kwargs)\n\n            # Return wrapped function\n            return recombine(*partition(pytree, filter_spec))\n        return inner_wrapper\n    return wrapper\n</code></pre>"},{"location":"docs/API/equinox/#zodiax.equinox","title":"Equinox","text":""},{"location":"docs/API/equinox/#zodiax.equinox.filter_grad","title":"Equinox","text":""},{"location":"docs/API/equinox/#zodiax.equinox.filter_value_and_grad","title":"Equinox","text":""},{"location":"docs/API/filter/","title":"Filter Module","text":"<p>The filter module is a very lightweight wrapper for the <code>equinox</code> filter functions. There are only two functions that are acutally modified, <code>filter_grad</code> and <code>filter_value_and_grad</code>. The rest of the functions are just wrappers for the <code>equinox</code> functions in order to have all filter functions accessible from the <code>filter</code> module.</p> <p>The modified functions simply allow for either a set of arguments or a pytree to be used to select which parameters are differentiated with respect to. This is useful when you want to differentiate with respect to a subset of the parameters, rather than the full model.</p> <p>Here is a simple example of the <code>filter_grad</code> function:</p> <pre><code>import zodiax as zdx\n\nclass Linear(zdx.ExtendedBase):\n    m : float\n    b : float\n\n    def __init__(self, m, b):\n        self.m = np.asarray(m, float)\n        self.b = np.asarray(b, float)\n\n    def model(self, x):\n        return self.m * x + self.b\n\n# Make model\nlinear = Linear(1, 2)\n\n# Differentiate with respect to the m parameter\nargs = 'm'\npytree_args = linear.get_args(args)\n\n# Use the arguments to filter the gradient\n@zdx.filter_grad(args)\ndef loss_fn(model, x):\n    return np.abs(model.model(x) - x)\n\n# Use the pytree to filter the gradient\n@zdx.filter_grad(pytree_args)\ndef loss_fn(model, x):\n    return np.square(model.model(x) - x)\n</code></pre> <p>The same syntax applies to the <code>filter_value_and_grad</code> function. All other functions are just wrappers for the <code>equinox</code> functions and therfore follow the same syntax.</p>"},{"location":"docs/API/optimisation/","title":"Optimisation","text":"<p>The <code>zodiax.optimisation</code> module contains only a single function, <code>get_optmiser</code>. It is a simple interface designed to apply Optax optimisers to individual leaves!</p> <p>Full API</p>"},{"location":"docs/API/optimisation/#zodiax.optimisation.get_optimiser","title":"<code>get_optimiser(pytree, paths, optimisers)</code>","text":"<p>Returns an Optax.GradientTransformion object, with the optimisers specified by optimisers applied to the leaves specified by paths.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>Union[str, list]</code> <p>A path or list of paths or list of nested paths.</p> required <code>optimisers</code> <code>Union[optax.GradientTransformation, list]</code> <p>A optax.GradientTransformation or list of optax.GradientTransformation objects to be applied to the leaves specified by paths.</p> required <p>Returns:</p> Type Description <code>optimiser, state</code> <p>A tuple of (Optax.GradientTransformion, optax.MultiTransformState) objects, with the optimisers applied to the leaves specified by paths, and the initialised optimisation state.</p> Source code in <code>zodiax/optimisation.py</code> <pre><code>def get_optimiser(pytree     : PyTree,\n                  paths      : Union[str, list],\n                  optimisers : Union[GradientTransformation, list],\n                  ) -&gt; tuple:\n\"\"\"\n    Returns an Optax.GradientTransformion object, with the optimisers\n    specified by optimisers applied to the leaves specified by paths.\n\n    Parameters\n    ----------\n    paths : Union[str, list]\n        A path or list of paths or list of nested paths.\n    optimisers : Union[optax.GradientTransformation, list]\n        A optax.GradientTransformation or list of\n        optax.GradientTransformation objects to be applied to the leaves\n        specified by paths.\n\n    Returns\n    -------\n    (optimiser, state) : tuple\n        A tuple of (Optax.GradientTransformion, optax.MultiTransformState)\n        objects, with the optimisers applied to the leaves specified by\n        paths, and the initialised optimisation state.\n    \"\"\"\n    # Pre-wrap single inputs into a list since optimisers have a length of 2\n    if not isinstance(optimisers, list):\n        optimisers = [optimisers]\n\n    # Construct groups and get param_spec\n    groups = [str(i) for i in range(len(optimisers))]\n    param_spec = tree_map(lambda _: \"null\", pytree)\n    param_spec = param_spec.set(paths, groups)\n\n    # Generate optimiser dictionary\n    opt_dict = dict([(groups[i], optimisers[i]) \\\n                        for i in range(len(groups))])\n\n    # Assign the null group\n    # TODO: Can this be set to None?\n    opt_dict[\"null\"] = adam(0.0)\n\n    # Get optimiser object\n    optim = multi_transform(opt_dict, param_spec)\n\n    # Get filtered optimiser\n    opt_state = optim.init(eqx_filter(pytree, is_array))\n\n    # Return\n    return (optim, opt_state)\n</code></pre>"},{"location":"docs/API/optimisation/#zodiax.optimisation","title":"Optimisation","text":""},{"location":"docs/API/optimisation/#zodiax.optimisation.get_optimiser","title":"Optimisation","text":""},{"location":"docs/API/serialisation/","title":"Serialisation","text":"<p>Warning</p> <p>This module is experimental and is subject to change!</p>"},{"location":"docs/API/serialisation/#overview","title":"Overview","text":"<p>This module is designed to be able to save and load models created in <code>zodiax</code> to and from a file. This is useful for saving the model for later use, or for sharing the model with others. Serialisation is a generally difficult problem to make fully robust, but can be constructed to cover most use cases!</p> <p>There are two main types of functions in this module: the structure function and the serialisation functions. There are two structure functions:</p> <ol> <li><code>structure = build_structure(obj)</code></li> <li><code>obj = load_structure(structure)</code></li> </ol> <p>The <code>build_structure</code> function traverses the input object and returns a <code>structure</code> dictionary that can be serialised. Each parameter in the object is either a 'container' node or a 'leaf' node, allowing the the full structure to be represented along with any nessecary meta-data required to reconstruct the object. The <code>load_structure()</code> function takes this <code>structure</code> dictionary and returns a pytree of the same structure that can be used in conjunction with <code>equinox.tree_serialise_leaves()</code> to return an identical object.</p> <p>The serialisation functions are:</p> <ol> <li><code>serialise(obj, path)</code></li> <li><code>obj = deserialise(path)</code></li> </ol> <p>The <code>serialise</code> function takes an object and a path, and saves the serialised object to the path. The <code>deserialise</code> function takes a path and returns the deserialised object.</p>"},{"location":"docs/API/serialisation/#future-changes","title":"Future changes","text":"<p>There are some future improvements that are planned for this module, hence the present experimental status!</p> <ul> <li> Serialise package versions:</li> </ul> <p>To try and ensure that the serialised object can be deserialised, the package versions should be serialised. This will allow the code to automatically check imported versions and raise warnings for imported package discrepancies.</p> <ul> <li> Add support for serialising functions:</li> </ul> <p>This should also raise warning as functions can not in general be robustly serialised, but should be supported.</p> <ul> <li> Deal with static_fields:</li> </ul> <p>There is a general issue with parameters in models that are marked as <code>equinox.static_field()</code>. Although this should rarely if even be used by the user, it is still a potential issue. Since the <code>equinox.tree_serialise_leaves()</code> function uses <code>tree_map</code> functions it is blind to these parameters. If this parameter is a string it is fine, however if it is some other data type it will at present not be serialised. This can be fixed by using the <code>tree_flatten()</code> function to determine what parameters are static and serialising them using a different method.</p> <ul> <li> Add support for serialising general objects:</li> </ul> <p>In order to deal with the above <code>static_field()</code> issue, we must add support for serialising general python types, along wth array types.</p> <ul> <li> Implement robust tests:</li> </ul> <p>The tests for this module are currently very basic, primarily becuase of the the tests are run in isolated enviroments, so classes that are created for the tests can not be re-imported.</p> <p>When these changes have been implemented this module can be moved into the main <code>zodiax</code> package.</p> <p>Full API</p>"},{"location":"docs/API/serialisation/#zodiax.experimental.serialisation.build_structure","title":"<code>build_structure(obj, self_key=None, depth=0, _print=False)</code>","text":"<p>Recursively iterates over the input object in order to return a dictionary  detailing the strucutre of the of the object. Each node can be either a conainter node or leaf node. Each node is a dictionary with the following structure:</p> <p>{'node_type': 'container' or 'leaf',  'type': str,  'node': {     param1 : {'node_type' : 'container', ...}, -&gt; If container     param2 : {'node_type' : 'leaf',               '...' : ...}, -&gt; If leaf conatining any leaf metadata     }</p> <p>Specific leaf metadata:     Strings:         String values are stored in the 'value' key and serialised via the         returned structure dictionary.     Jax/Numpy Arrays:         Both the array shape and dtype are stored in the 'shape' and         'dtype' keys respectively. </p> <p>This method can be developed further to support more leaf types, since each individual leaf type can be made to store any arbitrarity metadata, as long as it can be serialised by json and used to deserialise it later.</p> <p>This dictionary can then be serialised using pickle and then later used to deserialise the object in conjunction with equinox leaf  serialise/deserialise methods.</p> <p>NOTE: This method is not equipped to handle <code>equinox.static_field()</code>  parameters, as they can be arbitrary data types but do not get serialised by the  <code>equinox.serialise_tree_leaves()</code> methods and hence require custom  serialisation via this method. Therefore this method currently does not handle this case correctly. This is not checked for currently so will silently break or result in unexpected behaviour.</p> <p>TODO: Serialise package versions in order to raise warnings when  deserialising about inconsistent versions.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to get the leaves of.</p> required <code>self_key</code> <code>str</code> <p>The key of the object in the parent container. Use to print the tree structure for debugging.</p> <code>None</code> <code>depth</code> <code>int</code> <p>The depth of the object in the tree. Use to print the tree structure for debugging.</p> <code>0</code> <code>_print</code> <code>bool</code> <p>If True, print the tree structure for debugging.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>structure</code> <code>dict</code> <p>The dictionary detailing the structure of the object.</p> Source code in <code>zodiax/experimental/serialisation.py</code> <pre><code>def build_structure(obj      : Any, \n                    self_key : str  = None, \n                    depth    : int  = 0,\n                    _print   : bool = False):\n\"\"\"\n    Recursively iterates over the input object in order to return a dictionary \n    detailing the strucutre of the of the object. Each node can be either a\n    conainter node or leaf node. Each node is a dictionary with the following\n    structure:\n\n    {'node_type': 'container' or 'leaf',\n     'type': str,\n     'node': {\n        param1 : {'node_type' : 'container', ...}, -&gt; If container\n        param2 : {'node_type' : 'leaf',\n                  '...' : ...}, -&gt; If leaf conatining any leaf metadata\n        }\n\n    Specific leaf metadata:\n        Strings:\n            String values are stored in the 'value' key and serialised via the\n            returned structure dictionary.\n        Jax/Numpy Arrays:\n            Both the array shape and dtype are stored in the 'shape' and\n            'dtype' keys respectively. \n\n    This method can be developed further to support more leaf types, since each\n    individual leaf type can be made to store any arbitrarity metadata, as long\n    as it can be serialised by json and used to deserialise it later.\n\n    This dictionary can then be serialised using pickle and then later\n    used to deserialise the object in conjunction with equinox leaf \n    serialise/deserialise methods.\n\n    NOTE: This method is not equipped to handle `equinox.static_field()` \n    parameters, as they can be arbitrary data types but do not get serialised\n    by the  `equinox.serialise_tree_leaves()` methods and hence require custom \n    serialisation via this method. Therefore this method currently does not\n    handle this case correctly. This is not checked for currently so will\n    silently break or result in unexpected behaviour.\n\n    TODO: Serialise package versions in order to raise warnings when \n    deserialising about inconsistent versions.\n\n    Parameters\n    ----------\n    obj : Any\n        The object to get the leaves of.\n    self_key : str = None\n        The key of the object in the parent container. Use to print the tree\n        structure for debugging.\n    depth : int = 0\n        The depth of the object in the tree. Use to print the tree structure\n        for debugging.\n    _print : bool = False\n        If True, print the tree structure for debugging.\n\n    Returns\n    -------\n    structure : dict\n        The dictionary detailing the structure of the object.\n    \"\"\"\n    structure = {}\n    is_container = _check_node(obj, self_key, depth, _print=_print)\n\n    # Recursive case\n    if is_container:\n        keys, accessor = _get_accessor(obj)\n\n        # Iterate over parameters\n        for key in keys:\n            sub_obj = accessor(obj, key)\n            structure[key] = _build_node(sub_obj, key, depth, _print)\n\n        # Deal with outermost container\n        if depth == 0:\n            return _build_conatiner_node(obj, structure)\n        else:\n            return structure\n\n    # Base case    \n    else:\n        return obj\n</code></pre>"},{"location":"docs/API/serialisation/#zodiax.experimental.serialisation.deserialise","title":"<code>deserialise(path)</code>","text":"<p>Deserialises the input object at the input path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to serialise the object to.</p> required <p>Returns:</p> Name Type Description <code>obj</code> <code>Any</code> <p>The deserialised object.</p> Source code in <code>zodiax/experimental/serialisation.py</code> <pre><code>def deserialise(path : str):\n\"\"\"\n    Deserialises the input object at the input path.\n\n    Parameters\n    ----------\n    path : str\n        The path to serialise the object to.\n\n    Returns\n    -------\n    obj : Any\n        The deserialised object.\n    \"\"\"\n    with open(path, 'rb') as f:\n        structure = pickle.load(f)\n        like = load_structure(structure)\n        obj = tree_deserialise_leaves(f, like)\n    return obj\n</code></pre>"},{"location":"docs/API/serialisation/#zodiax.experimental.serialisation.load_structure","title":"<code>load_structure(structure)</code>","text":"<p>Load a structure from a dictionary to later be used in conjuction with <code>eqx.tree_deserialise_leaves()</code>.</p> <p>Custom leaf node desrialisation is handled by the <code>_load_leaf</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>dict</code> <p>The structure to load.</p> required <p>Returns:</p> Name Type Description <code>obj</code> <code>object</code> <p>The loaded structure.</p> Source code in <code>zodiax/experimental/serialisation.py</code> <pre><code>def load_structure(structure : dict) -&gt; object:\n\"\"\"\n    Load a structure from a dictionary to later be used in conjuction with\n    `eqx.tree_deserialise_leaves()`.\n\n\n    Custom leaf node desrialisation is handled by the `_load_leaf` function.\n\n    Parameters\n    ----------\n    structure : dict\n        The structure to load.\n\n    Returns\n    -------\n    obj : object\n        The loaded structure.\n    \"\"\"\n    # Construct the object\n    obj = _construct_class(structure['type'])\n\n    # Container Node\n    if structure['node_type'] == 'container': \n\n        # Iterarte over all parameters and update the object\n        for key, value in structure['node'].items():\n            obj = _load_container(obj, key, value)\n        return obj\n\n    # Leaf Node\n    else: \n        return _load_leaf(obj, structure)\n</code></pre>"},{"location":"docs/API/serialisation/#zodiax.experimental.serialisation.serialise","title":"<code>serialise(path, obj)</code>","text":"<p>Serialises the input zodiax pytree to the input path. This method works by creating a dictionary detailing the structure of the object to be serialised. This dictionary is then serialised using <code>pickle</code> and the  pytree leaves are serialised using <code>equinox.serialise_tree_leaves()</code>. This object can then be deserialised using the <code>deserialise()</code> method. </p> <p>This method is currently considered experimental for a number of reasons:  - Some objects can not be gaurenteed to be deserialised correctly.   - User-defined classes can be serialised but it is up to the user to   import the class into the global namespace when deserialising.   - User defined functions can not be gaurenteed to be deserialised  correctly.  - Different versions of packages can cause issues when deserialising. This metadata is planned to be serialised in the future and have warnings raised when deserialising.  - static_field() parameters are not handled correctly. Since array types  can be set as static_field() parameters, they are not serialised by  <code>equinox.serialise_tree_leaves()</code> and hence require custom serialisation  via this method. This is not checked for currently so will silently break.  This can be fixed with some pre-filtering and type checking using the  <code>.tree_flatten()</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to serialise the object to.</p> required <code>obj</code> <code>Any</code> <p>The object to serialise.</p> required Source code in <code>zodiax/experimental/serialisation.py</code> <pre><code>def serialise(path : str, obj : Any) -&gt; None:\n\"\"\"\n    Serialises the input zodiax pytree to the input path. This method works by\n    creating a dictionary detailing the structure of the object to be\n    serialised. This dictionary is then serialised using `pickle` and the \n    pytree leaves are serialised using `equinox.serialise_tree_leaves()`. This\n    object can then be deserialised using the `deserialise()` method. \n\n    This method is currently considered experimental for a number of reasons:\n     - Some objects can not be gaurenteed to be deserialised correctly. \n     - User-defined classes _can_ be serialised but it is up to the user to \n     import the class into the global namespace when deserialising. \n     - User defined functions can not be gaurenteed to be deserialised\n     correctly.\n     - Different versions of packages can cause issues when deserialising. This\n    metadata is planned to be serialised in the future and have warnings raised\n    when deserialising.\n     - static_field() parameters are not handled correctly. Since array types\n     can be set as static_field() parameters, they are not serialised by\n     `equinox.serialise_tree_leaves()` and hence require custom serialisation\n     via this method. This is not checked for currently so will silently break.\n     This can be fixed with some pre-filtering and type checking using the\n     `.tree_flatten()` method.\n\n    Parameters\n    ----------\n    path : str\n        The path to serialise the object to.\n    obj : Any\n        The object to serialise.\n    \"\"\"\n    structure = build_structure(obj)\n    with open(path, 'wb') as f:\n        pickle.dump(structure, f)\n        tree_serialise_leaves(f, obj)\n</code></pre>"},{"location":"docs/API/serialisation/#zodiax.experimental.serialisation","title":"Serialisation","text":""},{"location":"docs/API/serialisation/#zodiax.experimental.serialisation.build_structure","title":"Serialisation","text":""},{"location":"docs/API/serialisation/#zodiax.experimental.serialisation.deserialise","title":"Serialisation","text":""},{"location":"docs/API/serialisation/#zodiax.experimental.serialisation.load_structure","title":"Serialisation","text":""},{"location":"docs/API/serialisation/#zodiax.experimental.serialisation.serialise","title":"Serialisation","text":""},{"location":"docs/API/tree/","title":"Tree","text":"<p>The Tree module provides a module for helpful pytree manipulation functions. It only implements a single function, <code>get_args(paths)</code>. It returns a matching pytree with boolean leaves, where the leaves specified by <code>paths</code> are <code>True</code> and the rest are <code>False</code>.</p> <p>Full API</p>"},{"location":"docs/API/tree/#zodiax.tree.get_args","title":"<code>get_args(pytree, paths)</code>","text":"<p>Returns a pytree of matching structure with boolean values at the leaves. Leaves specified by paths will be True, all others will be False. </p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>Union[str, list]</code> <p>A path or list of paths or list of nested paths.</p> required <p>Returns:</p> Name Type Description <code>args</code> <code>PyTree</code> <p>An pytree of matching structre with boolean values at the leaves.</p> Source code in <code>zodiax/tree.py</code> <pre><code>def get_args(pytree: PyTree, paths : Union[str, list]) -&gt; PyTree:\n\"\"\"\n    Returns a pytree of matching structure with boolean values at the leaves.\n    Leaves specified by paths will be True, all others will be False. \n\n    Parameters\n    ----------\n    paths : Union[str, list]\n        A path or list of paths or list of nested paths.\n\n    Returns\n    -------\n    args : PyTree\n        An pytree of matching structre with boolean values at the leaves.\n    \"\"\"\n    args = tree_map(lambda _: False, pytree)\n    paths = paths if isinstance(paths, list) else [paths]\n    values = len(paths) * [True]\n    return args.set(paths, values)\n</code></pre>"},{"location":"docs/API/tree/#zodiax.tree","title":"Tree","text":""},{"location":"docs/API/tree/#zodiax.tree.get_args","title":"Tree","text":""}]}